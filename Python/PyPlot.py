# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _PyPlot
else:
    import _PyPlot

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class float_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.float_numeric_limits_min(self)

    def max(self):
        return _PyPlot.float_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.float_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.float_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.float_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.float_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.float_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.float_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.float_numeric_limits_swiginit(self, _PyPlot.new_float_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_float_numeric_limits

# Register float_numeric_limits in _PyPlot:
_PyPlot.float_numeric_limits_swigregister(float_numeric_limits)

class double_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.double_numeric_limits_min(self)

    def max(self):
        return _PyPlot.double_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.double_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.double_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.double_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.double_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.double_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.double_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.double_numeric_limits_swiginit(self, _PyPlot.new_double_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_double_numeric_limits

# Register double_numeric_limits in _PyPlot:
_PyPlot.double_numeric_limits_swigregister(double_numeric_limits)

class int_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.int_numeric_limits_min(self)

    def max(self):
        return _PyPlot.int_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.int_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.int_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.int_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.int_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.int_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.int_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.int_numeric_limits_swiginit(self, _PyPlot.new_int_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_int_numeric_limits

# Register int_numeric_limits in _PyPlot:
_PyPlot.int_numeric_limits_swigregister(int_numeric_limits)

class uint_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.uint_numeric_limits_min(self)

    def max(self):
        return _PyPlot.uint_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.uint_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.uint_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.uint_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.uint_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.uint_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.uint_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.uint_numeric_limits_swiginit(self, _PyPlot.new_uint_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_uint_numeric_limits

# Register uint_numeric_limits in _PyPlot:
_PyPlot.uint_numeric_limits_swigregister(uint_numeric_limits)

class short_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.short_numeric_limits_min(self)

    def max(self):
        return _PyPlot.short_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.short_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.short_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.short_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.short_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.short_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.short_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.short_numeric_limits_swiginit(self, _PyPlot.new_short_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_short_numeric_limits

# Register short_numeric_limits in _PyPlot:
_PyPlot.short_numeric_limits_swigregister(short_numeric_limits)

class ushort_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.ushort_numeric_limits_min(self)

    def max(self):
        return _PyPlot.ushort_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.ushort_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.ushort_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.ushort_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.ushort_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.ushort_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.ushort_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.ushort_numeric_limits_swiginit(self, _PyPlot.new_ushort_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_ushort_numeric_limits

# Register ushort_numeric_limits in _PyPlot:
_PyPlot.ushort_numeric_limits_swigregister(ushort_numeric_limits)

class long_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.long_numeric_limits_min(self)

    def max(self):
        return _PyPlot.long_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.long_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.long_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.long_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.long_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.long_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.long_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.long_numeric_limits_swiginit(self, _PyPlot.new_long_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_long_numeric_limits

# Register long_numeric_limits in _PyPlot:
_PyPlot.long_numeric_limits_swigregister(long_numeric_limits)

class ulong_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.ulong_numeric_limits_min(self)

    def max(self):
        return _PyPlot.ulong_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.ulong_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.ulong_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.ulong_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.ulong_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.ulong_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.ulong_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.ulong_numeric_limits_swiginit(self, _PyPlot.new_ulong_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_ulong_numeric_limits

# Register ulong_numeric_limits in _PyPlot:
_PyPlot.ulong_numeric_limits_swigregister(ulong_numeric_limits)

class llong_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.llong_numeric_limits_min(self)

    def max(self):
        return _PyPlot.llong_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.llong_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.llong_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.llong_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.llong_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.llong_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.llong_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.llong_numeric_limits_swiginit(self, _PyPlot.new_llong_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_llong_numeric_limits

# Register llong_numeric_limits in _PyPlot:
_PyPlot.llong_numeric_limits_swigregister(llong_numeric_limits)

class ullong_numeric_limits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def min(self):
        return _PyPlot.ullong_numeric_limits_min(self)

    def max(self):
        return _PyPlot.ullong_numeric_limits_max(self)

    def epsilon(self):
        return _PyPlot.ullong_numeric_limits_epsilon(self)

    def round_error(self):
        return _PyPlot.ullong_numeric_limits_round_error(self)

    def infinity(self):
        return _PyPlot.ullong_numeric_limits_infinity(self)

    def quiet_NaN(self):
        return _PyPlot.ullong_numeric_limits_quiet_NaN(self)

    def signaling_NaN(self):
        return _PyPlot.ullong_numeric_limits_signaling_NaN(self)

    def denorm_min(self):
        return _PyPlot.ullong_numeric_limits_denorm_min(self)

    def __init__(self):
        _PyPlot.ullong_numeric_limits_swiginit(self, _PyPlot.new_ullong_numeric_limits())
    __swig_destroy__ = _PyPlot.delete_ullong_numeric_limits

# Register ullong_numeric_limits in _PyPlot:
_PyPlot.ullong_numeric_limits_swigregister(ullong_numeric_limits)


def Huge():
    return _PyPlot.Huge()

def Hugef():
    return _PyPlot.Hugef()

def Infinity():
    return _PyPlot.Infinity()

def NaN():
    return _PyPlot.NaN()
char_bit = _PyPlot.char_bit
schar_min = _PyPlot.schar_min
schar_max = _PyPlot.schar_max
uchar_max = _PyPlot.uchar_max
char_min = _PyPlot.char_min
char_max = _PyPlot.char_max
mb_len_max = _PyPlot.mb_len_max
shrt_min = _PyPlot.shrt_min
shrt_max = _PyPlot.shrt_max
ushrt_max = _PyPlot.ushrt_max
int_min = _PyPlot.int_min
int_max = _PyPlot.int_max
uint_max = _PyPlot.uint_max
long_min = _PyPlot.long_min
long_max = _PyPlot.long_max
ulong_max = _PyPlot.ulong_max
llong_min = _PyPlot.llong_min
llong_max = _PyPlot.llong_max
ullong_max = _PyPlot.ullong_max
class string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _PyPlot.string_swiginit(self, _PyPlot.new_string(*args))

    def __getitem__(self, i):
        return _PyPlot.string___getitem__(self, i)

    def __setitem__(self, i, c):
        return _PyPlot.string___setitem__(self, i, c)

    def __str__(self):
        return _PyPlot.string___str__(self)

    def to_int32(self, base=10):
        return _PyPlot.string_to_int32(self, base)

    def to_int64(self, base=10):
        return _PyPlot.string_to_int64(self, base)

    def to_float(self):
        return _PyPlot.string_to_float(self)

    def to_double(self):
        return _PyPlot.string_to_double(self)

    def reverse(self):
        return _PyPlot.string_reverse(self)

    def sort(self):
        return _PyPlot.string_sort(self)

    def shuffle(self):
        return _PyPlot.string_shuffle(self)

    def getline(self):
        return _PyPlot.string_getline(self)

    def fill(self, i, c):
        return _PyPlot.string_fill(self, i, c)

    def data(self):
        return _PyPlot.string_data(self)

    def size(self):
        return _PyPlot.string_size(self)

    def empty(self):
        return _PyPlot.string_empty(self)

    def clear(self):
        return _PyPlot.string_clear(self)

    def erase(self, i, n=1):
        return _PyPlot.string_erase(self, i, n)

    def push_back(self, c):
        return _PyPlot.string_push_back(self, c)

    def pop_back(self):
        return _PyPlot.string_pop_back(self)

    def replace(self, pos, count, s):
        return _PyPlot.string_replace(self, pos, count, s)

    def resize(self, i):
        return _PyPlot.string_resize(self, i)

    def substr(self, i, n):
        return _PyPlot.string_substr(self, i, n)

    def find(self, s, pos=0):
        return _PyPlot.string_find(self, s, pos)

    def rfind(self, s, pos=0):
        return _PyPlot.string_rfind(self, s, pos)

    def compare(self, b):
        return _PyPlot.string_compare(self, b)
    __swig_destroy__ = _PyPlot.delete_string

# Register string in _PyPlot:
_PyPlot.string_swigregister(string)

class float_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _PyPlot.float_vector_swiginit(self, _PyPlot.new_float_vector(*args))

    def __getitem__(self, i):
        return _PyPlot.float_vector___getitem__(self, i)

    def __setitem__(self, i, val):
        return _PyPlot.float_vector___setitem__(self, i, val)

    def ibegin(self):
        return _PyPlot.float_vector_ibegin(self)

    def iend(self):
        return _PyPlot.float_vector_iend(self)

    def erase(self, *args):
        return _PyPlot.float_vector_erase(self, *args)

    def front(self):
        return _PyPlot.float_vector_front(self)

    def back(self):
        return _PyPlot.float_vector_back(self)

    def push_back(self, q):
        return _PyPlot.float_vector_push_back(self, q)

    def pop_back(self):
        return _PyPlot.float_vector_pop_back(self)

    def at(self, i):
        return _PyPlot.float_vector_at(self, i)

    def assign(self, n, val):
        return _PyPlot.float_vector_assign(self, n, val)

    def data(self):
        return _PyPlot.float_vector_data(self)

    def size(self):
        return _PyPlot.float_vector_size(self)

    def empty(self):
        return _PyPlot.float_vector_empty(self)

    def resize(self, n):
        return _PyPlot.float_vector_resize(self, n)

    def clear(self):
        return _PyPlot.float_vector_clear(self)

    def swap(self, x):
        return _PyPlot.float_vector_swap(self, x)

    def shrink_to_fit(self):
        return _PyPlot.float_vector_shrink_to_fit(self)

    def reserve(self, n):
        return _PyPlot.float_vector_reserve(self, n)

    def max_size(self):
        return _PyPlot.float_vector_max_size(self)

    def capacity(self):
        return _PyPlot.float_vector_capacity(self)
    __swig_destroy__ = _PyPlot.delete_float_vector

# Register float_vector in _PyPlot:
_PyPlot.float_vector_swigregister(float_vector)

class double_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _PyPlot.double_vector_swiginit(self, _PyPlot.new_double_vector(*args))

    def __getitem__(self, i):
        return _PyPlot.double_vector___getitem__(self, i)

    def __setitem__(self, i, val):
        return _PyPlot.double_vector___setitem__(self, i, val)

    def ibegin(self):
        return _PyPlot.double_vector_ibegin(self)

    def iend(self):
        return _PyPlot.double_vector_iend(self)

    def erase(self, *args):
        return _PyPlot.double_vector_erase(self, *args)

    def front(self):
        return _PyPlot.double_vector_front(self)

    def back(self):
        return _PyPlot.double_vector_back(self)

    def push_back(self, q):
        return _PyPlot.double_vector_push_back(self, q)

    def pop_back(self):
        return _PyPlot.double_vector_pop_back(self)

    def at(self, i):
        return _PyPlot.double_vector_at(self, i)

    def assign(self, n, val):
        return _PyPlot.double_vector_assign(self, n, val)

    def data(self):
        return _PyPlot.double_vector_data(self)

    def size(self):
        return _PyPlot.double_vector_size(self)

    def empty(self):
        return _PyPlot.double_vector_empty(self)

    def resize(self, n):
        return _PyPlot.double_vector_resize(self, n)

    def clear(self):
        return _PyPlot.double_vector_clear(self)

    def swap(self, x):
        return _PyPlot.double_vector_swap(self, x)

    def shrink_to_fit(self):
        return _PyPlot.double_vector_shrink_to_fit(self)

    def reserve(self, n):
        return _PyPlot.double_vector_reserve(self, n)

    def max_size(self):
        return _PyPlot.double_vector_max_size(self)

    def capacity(self):
        return _PyPlot.double_vector_capacity(self)
    __swig_destroy__ = _PyPlot.delete_double_vector

# Register double_vector in _PyPlot:
_PyPlot.double_vector_swigregister(double_vector)

class complex_float_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _PyPlot.complex_float_vector_swiginit(self, _PyPlot.new_complex_float_vector(*args))

    def __getitem__(self, i):
        return _PyPlot.complex_float_vector___getitem__(self, i)

    def __setitem__(self, i, val):
        return _PyPlot.complex_float_vector___setitem__(self, i, val)

    def ibegin(self):
        return _PyPlot.complex_float_vector_ibegin(self)

    def iend(self):
        return _PyPlot.complex_float_vector_iend(self)

    def erase(self, *args):
        return _PyPlot.complex_float_vector_erase(self, *args)

    def front(self):
        return _PyPlot.complex_float_vector_front(self)

    def back(self):
        return _PyPlot.complex_float_vector_back(self)

    def push_back(self, q):
        return _PyPlot.complex_float_vector_push_back(self, q)

    def pop_back(self):
        return _PyPlot.complex_float_vector_pop_back(self)

    def at(self, i):
        return _PyPlot.complex_float_vector_at(self, i)

    def assign(self, n, val):
        return _PyPlot.complex_float_vector_assign(self, n, val)

    def data(self):
        return _PyPlot.complex_float_vector_data(self)

    def size(self):
        return _PyPlot.complex_float_vector_size(self)

    def empty(self):
        return _PyPlot.complex_float_vector_empty(self)

    def resize(self, n):
        return _PyPlot.complex_float_vector_resize(self, n)

    def clear(self):
        return _PyPlot.complex_float_vector_clear(self)

    def swap(self, x):
        return _PyPlot.complex_float_vector_swap(self, x)

    def shrink_to_fit(self):
        return _PyPlot.complex_float_vector_shrink_to_fit(self)

    def reserve(self, n):
        return _PyPlot.complex_float_vector_reserve(self, n)

    def max_size(self):
        return _PyPlot.complex_float_vector_max_size(self)

    def capacity(self):
        return _PyPlot.complex_float_vector_capacity(self)
    __swig_destroy__ = _PyPlot.delete_complex_float_vector

# Register complex_float_vector in _PyPlot:
_PyPlot.complex_float_vector_swigregister(complex_float_vector)

class complex_double_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _PyPlot.complex_double_vector_swiginit(self, _PyPlot.new_complex_double_vector(*args))

    def __getitem__(self, i):
        return _PyPlot.complex_double_vector___getitem__(self, i)

    def __setitem__(self, i, val):
        return _PyPlot.complex_double_vector___setitem__(self, i, val)

    def ibegin(self):
        return _PyPlot.complex_double_vector_ibegin(self)

    def iend(self):
        return _PyPlot.complex_double_vector_iend(self)

    def erase(self, *args):
        return _PyPlot.complex_double_vector_erase(self, *args)

    def front(self):
        return _PyPlot.complex_double_vector_front(self)

    def back(self):
        return _PyPlot.complex_double_vector_back(self)

    def push_back(self, q):
        return _PyPlot.complex_double_vector_push_back(self, q)

    def pop_back(self):
        return _PyPlot.complex_double_vector_pop_back(self)

    def at(self, i):
        return _PyPlot.complex_double_vector_at(self, i)

    def assign(self, n, val):
        return _PyPlot.complex_double_vector_assign(self, n, val)

    def data(self):
        return _PyPlot.complex_double_vector_data(self)

    def size(self):
        return _PyPlot.complex_double_vector_size(self)

    def empty(self):
        return _PyPlot.complex_double_vector_empty(self)

    def resize(self, n):
        return _PyPlot.complex_double_vector_resize(self, n)

    def clear(self):
        return _PyPlot.complex_double_vector_clear(self)

    def swap(self, x):
        return _PyPlot.complex_double_vector_swap(self, x)

    def shrink_to_fit(self):
        return _PyPlot.complex_double_vector_shrink_to_fit(self)

    def reserve(self, n):
        return _PyPlot.complex_double_vector_reserve(self, n)

    def max_size(self):
        return _PyPlot.complex_double_vector_max_size(self)

    def capacity(self):
        return _PyPlot.complex_double_vector_capacity(self)
    __swig_destroy__ = _PyPlot.delete_complex_double_vector

# Register complex_double_vector in _PyPlot:
_PyPlot.complex_double_vector_swigregister(complex_double_vector)

GP_MAX_TMP_FILES = _PyPlot.GP_MAX_TMP_FILES
class gnuplot_ctrl(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    gnucmd = property(_PyPlot.gnuplot_ctrl_gnucmd_get, _PyPlot.gnuplot_ctrl_gnucmd_set)
    nplots = property(_PyPlot.gnuplot_ctrl_nplots_get, _PyPlot.gnuplot_ctrl_nplots_set)
    pstyle = property(_PyPlot.gnuplot_ctrl_pstyle_get, _PyPlot.gnuplot_ctrl_pstyle_set)
    tmp_filename_tbl = property(_PyPlot.gnuplot_ctrl_tmp_filename_tbl_get, _PyPlot.gnuplot_ctrl_tmp_filename_tbl_set)
    ntmp = property(_PyPlot.gnuplot_ctrl_ntmp_get, _PyPlot.gnuplot_ctrl_ntmp_set)

    def __init__(self):
        _PyPlot.gnuplot_ctrl_swiginit(self, _PyPlot.new_gnuplot_ctrl())
    __swig_destroy__ = _PyPlot.delete_gnuplot_ctrl

# Register gnuplot_ctrl in _PyPlot:
_PyPlot.gnuplot_ctrl_swigregister(gnuplot_ctrl)

class Plot_Float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    handle = property(_PyPlot.Plot_Float_handle_get, _PyPlot.Plot_Float_handle_set)

    def __init__(self):
        _PyPlot.Plot_Float_swiginit(self, _PyPlot.new_Plot_Float())
    __swig_destroy__ = _PyPlot.delete_Plot_Float

    def cmd(self, cmd):
        return _PyPlot.Plot_Float_cmd(self, cmd)

    def setstyle(self, plot_style):
        return _PyPlot.Plot_Float_setstyle(self, plot_style)

    def set_xlabel(self, label):
        return _PyPlot.Plot_Float_set_xlabel(self, label)

    def set_ylabel(self, label):
        return _PyPlot.Plot_Float_set_ylabel(self, label)

    def resetplot(self):
        return _PyPlot.Plot_Float_resetplot(self)

    def plot_x(self, d, n, title):
        return _PyPlot.Plot_Float_plot_x(self, d, n, title)

    def plot_xy(self, x, y, n, title):
        return _PyPlot.Plot_Float_plot_xy(self, x, y, n, title)

    def plot_once(self, title, style, label_x, label_y, x, y, n):
        return _PyPlot.Plot_Float_plot_once(self, title, style, label_x, label_y, x, y, n)

    def plot_slope(self, a, b, title):
        return _PyPlot.Plot_Float_plot_slope(self, a, b, title)

    def plot_equation(self, equation, title):
        return _PyPlot.Plot_Float_plot_equation(self, equation, title)

    def write_x_csv(self, fileName, d, n, title):
        return _PyPlot.Plot_Float_write_x_csv(self, fileName, d, n, title)

    def write_xy_csv(self, fileName, x, y, n, title):
        return _PyPlot.Plot_Float_write_xy_csv(self, fileName, x, y, n, title)

    def write_multi_csv(self, fileName, xListPtr, n, numColumns, title):
        return _PyPlot.Plot_Float_write_multi_csv(self, fileName, xListPtr, n, numColumns, title)

    def tmpfile(self):
        return _PyPlot.Plot_Float_tmpfile(self)

    def plot_atmpfile(self, tmp_filename, title):
        return _PyPlot.Plot_Float_plot_atmpfile(self, tmp_filename, title)

# Register Plot_Float in _PyPlot:
_PyPlot.Plot_Float_swigregister(Plot_Float)

class Plot_Double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    handle = property(_PyPlot.Plot_Double_handle_get, _PyPlot.Plot_Double_handle_set)

    def __init__(self):
        _PyPlot.Plot_Double_swiginit(self, _PyPlot.new_Plot_Double())
    __swig_destroy__ = _PyPlot.delete_Plot_Double

    def cmd(self, cmd):
        return _PyPlot.Plot_Double_cmd(self, cmd)

    def setstyle(self, plot_style):
        return _PyPlot.Plot_Double_setstyle(self, plot_style)

    def set_xlabel(self, label):
        return _PyPlot.Plot_Double_set_xlabel(self, label)

    def set_ylabel(self, label):
        return _PyPlot.Plot_Double_set_ylabel(self, label)

    def resetplot(self):
        return _PyPlot.Plot_Double_resetplot(self)

    def plot_x(self, d, n, title):
        return _PyPlot.Plot_Double_plot_x(self, d, n, title)

    def plot_xy(self, x, y, n, title):
        return _PyPlot.Plot_Double_plot_xy(self, x, y, n, title)

    def plot_once(self, title, style, label_x, label_y, x, y, n):
        return _PyPlot.Plot_Double_plot_once(self, title, style, label_x, label_y, x, y, n)

    def plot_slope(self, a, b, title):
        return _PyPlot.Plot_Double_plot_slope(self, a, b, title)

    def plot_equation(self, equation, title):
        return _PyPlot.Plot_Double_plot_equation(self, equation, title)

    def write_x_csv(self, fileName, d, n, title):
        return _PyPlot.Plot_Double_write_x_csv(self, fileName, d, n, title)

    def write_xy_csv(self, fileName, x, y, n, title):
        return _PyPlot.Plot_Double_write_xy_csv(self, fileName, x, y, n, title)

    def write_multi_csv(self, fileName, xListPtr, n, numColumns, title):
        return _PyPlot.Plot_Double_write_multi_csv(self, fileName, xListPtr, n, numColumns, title)

    def tmpfile(self):
        return _PyPlot.Plot_Double_tmpfile(self)

    def plot_atmpfile(self, tmp_filename, title):
        return _PyPlot.Plot_Double_plot_atmpfile(self, tmp_filename, title)

# Register Plot_Double in _PyPlot:
_PyPlot.Plot_Double_swigregister(Plot_Double)



